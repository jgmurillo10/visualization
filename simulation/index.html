<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Force Tutorial</title>
  </head>
  <body>
    <h1>Force Tutorial</h1>
    <canvas id="network" width="500" height="500"></canvas>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="netClustering.js"></script>
    <script src="forceInABox.js"></script>
    <script src="NodeNavigator.js"></script>
    <script type="text/javascript">
      var canvas = d3.select("#network"),
      //returns the html or dom element
      ctx = canvas.node().getContext("2d"),
      width = canvas.attr("width"),
      height = canvas.attr("height"),
      r = 3,
      color = d3.scaleOrdinal(d3.schemeCategory20),
      x = d3.scaleOrdinal() .range([20,width-20]),
      simulation = d3.forceSimulation()
                    //  .force("x",d3.forceX(d=>x(d.party)).strength(0.7))
                    //  .force("y",d3.forceY(height/2))
                    //  .force("collide", d3.forceCollide(r+1))
                     .force("center", d3.forceCenter(width/2,height/2))
                     .force("charge", d3.forceManyBody()
                                        .strength(-20))
                    //avoid setting x and y attribute to source and target of the links
                     .force("link", d3.forceLink()
                                      .id(function (d) {
                                        return d.name;
                                      }));
      d3.json("VotacionesSenado2017.json", function (err,graph) {
        var dicNodes = d3.map();
        graph.nodes.forEach(function (n) {
          n.degree = 0;
          n.visible = true;
          // n.cluster = -1;
          n.id = +n.id;
          dicNodes.set(n.id, n);
        });
        graph.links.forEach(function (e) {
        // e.count = +e.count;
        if (dicNodes.has(e.source.id)) {
          e.source = dicNodes.get(e.source.id);
        } else {
          e.source = {
            id:e.source,
            name:e.source,
            degree:0,
            // cluster: -1,
            screen_name:e.target,
            count:1
          };
          dicNodes.set(e.source.id, e.source);
        }

        e.source.degree+=1;

        if (dicNodes.has(e.target.id)) {
          e.target = dicNodes.get(e.target.id);
        } else {
          e.target = {
            id:e.target,
            name:e.target,
            degree:0,
            // cluster: -1,
            screen_name:e.target,
            count:1
          };
          dicNodes.set(e.target.id, e.target);
        }

        e.target.degree+=1;
      });
      var minDegree = 2;
      // var filteredLinks = graph.links.filter(function (e) {
      //   return e.count_followers_in_query > minDegree;
      // });
      var filteredLinks = graph.links;
      var filteredGraph = {
        nodes: dicNodes.values(),
        links: filteredLinks
      };

      if (err) throw err;

      nodeNavigator.links(filteredGraph.links);
      nodeNavigator.data(filteredGraph.nodes);
      nodeNavigator.updateCallback(function (nodes) {
        update({
          nodes:nodes,
          links:graph.links
        });
      });

      update(filteredGraph);
    });

    var nodeNavigator = new NodeNavigator(
      "#nn",
      height
    ).id("screen_name");

      function update() {
        //clear the whole canvas
         ctx.clearRect(0,0, width, height);

         ctx.beginPath();
         ctx.globalAlpha = 0.1;
         ctx.strokeStyle = "#aaa";
         graph.links.forEach(drawLink);
         ctx.stroke ();


         ctx.globalAlpha = 1.0;
         graph.nodes.forEach(drawNode);

      }






      function drawNode(d) {
        ctx.beginPath();
        ctx.fillStyle = color(d.party);
        ctx.moveTo(d.x,d.y);
        ctx.arc(d.x,d.y, r,0,2*Math.PI)
        ctx.fill();
      }
      function drawLink(d) {
        ctx.moveTo(d.source.x,d.source.y);
        ctx.lineTo(d.target.x,d.target.y);
      }
    </script>
  </body>
</html>
